const schema = {"$schema":"http://json-schema.org/draft-07/schema#","definitions":{"RequestBody":{"type":"object","properties":{"accepted":{"description":"Return an array of Accepted media types\nordered from highest quality to lowest.","type":"array","items":{"type":"object","properties":{"value":{"type":"string"},"quality":{"type":"number"},"type":{"type":"string"},"subtype":{"type":"string"}},"required":["quality","subtype","type","value"]}},"protocol":{"description":"Return the protocol string \"http\" or \"https\"\nwhen requested with TLS. When the \"trust proxy\"\nsetting is enabled the \"X-Forwarded-Proto\" header\nfield will be trusted. If you're running behind\na reverse proxy that supplies https for you this\nmay be enabled.","type":"string"},"secure":{"description":"Short-hand for:\n\n   req.protocol == 'https'","type":"boolean"},"ip":{"description":"Return the remote address, or when\n\"trust proxy\" is `true` return\nthe upstream addr.","type":"string"},"ips":{"description":"When \"trust proxy\" is `true`, parse\nthe \"X-Forwarded-For\" ip address list.\n\nFor example if the value were \"client, proxy1, proxy2\"\nyou would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\nwhere \"proxy2\" is the furthest down-stream.","type":"array","items":{"type":"string"}},"subdomains":{"description":"Return subdomains as an array.\n\nSubdomains are the dot-separated parts of the host before the main domain of\nthe app. By default, the domain of the app is assumed to be the last two\nparts of the host. This can be changed by setting \"subdomain offset\".\n\nFor example, if the domain is \"tobi.ferrets.example.com\":\nIf \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\nIf \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.","type":"array","items":{"type":"string"}},"path":{"description":"Short-hand for `url.parse(req.url).pathname`.","type":"string"},"hostname":{"description":"Parse the \"Host\" header field hostname.","type":"string"},"host":{"type":"string"},"fresh":{"description":"Check if the request is fresh, aka\nLast-Modified and/or the ETag\nstill match.","type":"boolean"},"stale":{"description":"Check if the request is stale, aka\n\"Last-Modified\" and / or the \"ETag\" for the\nresource has changed.","type":"boolean"},"xhr":{"description":"Check if the request was an _XMLHttpRequest_.","type":"boolean"},"body":{"type":"object"},"cookies":{},"method":{"description":"**Only valid for request obtained from {@link Server}.**\n\nThe request method as a string. Read only. Examples: `'GET'`, `'DELETE'`.","type":"string"},"params":{"type":"object","properties":{}},"query":{"$ref":"#/definitions/qs.ParsedQs"},"route":{},"signedCookies":{},"originalUrl":{"type":"string"},"url":{"description":"**Only valid for request obtained from {@link Server}.**\n\nRequest URL string. This contains only the URL that is present in the actual\nHTTP request. Take the following request:\n\n```http\nGET /status?name=ryan HTTP/1.1\nAccept: text/plain\n```\n\nTo parse the URL into its parts:\n\n```js\nnew URL(request.url, `http://${request.getHeaders().host}`);\n```\n\nWhen `request.url` is `'/status?name=ryan'` and`request.getHeaders().host` is `'localhost:3000'`:\n\n```console\n$ node\n> new URL(request.url, `http://${request.getHeaders().host}`)\nURL {\n  href: 'http://localhost:3000/status?name=ryan',\n  origin: 'http://localhost:3000',\n  protocol: 'http:',\n  username: '',\n  password: '',\n  host: 'localhost:3000',\n  hostname: 'localhost',\n  port: '3000',\n  pathname: '/status',\n  search: '?name=ryan',\n  searchParams: URLSearchParams { 'name' => 'ryan' },\n  hash: ''\n}\n```","type":"string"},"baseUrl":{"type":"string"},"app":{"type":"object","properties":{"get":{"type":"object"},"router":{"type":"string"},"settings":{},"resource":{},"map":{},"locals":{"type":"object"},"routes":{"description":"The app.routes object houses all of the routes defined mapped by the\nassociated HTTP verb. This object may be used for introspection\ncapabilities, for example Express uses this internally not only for\nrouting but to provide default OPTIONS behaviour unless app.options()\nis used. Your application or framework may also remove routes by\nsimply by removing them from this object."},"_router":{"description":"Used to get all registered routes in Express Application"},"use":{"type":"object"},"on":{"description":"The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.","type":"object"},"mountpath":{"description":"The app.mountpath property contains one or more path patterns on which a sub-app was mounted.","anyOf":[{"type":"array","items":{"type":"string"}},{"type":"string"}]},"all":{"description":"Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.","type":"object"},"post":{"type":"object"},"put":{"type":"object"},"delete":{"type":"object"},"patch":{"type":"object"},"options":{"type":"object"},"head":{"type":"object"},"checkout":{"type":"object"},"connect":{"type":"object"},"copy":{"type":"object"},"lock":{"type":"object"},"merge":{"type":"object"},"mkactivity":{"type":"object"},"mkcol":{"type":"object"},"move":{"type":"object"},"m-search":{"type":"object"},"notify":{"type":"object"},"propfind":{"type":"object"},"proppatch":{"type":"object"},"purge":{"type":"object"},"report":{"type":"object"},"search":{"type":"object"},"subscribe":{"type":"object"},"trace":{"type":"object"},"unlock":{"type":"object"},"unsubscribe":{"type":"object"},"stack":{"description":"Stack of configured routes","type":"array","items":{}}},"required":["_router","all","checkout","connect","copy","delete","get","head","locals","lock","m-search","map","merge","mkactivity","mkcol","mountpath","move","notify","on","options","patch","post","propfind","proppatch","purge","put","report","resource","router","routes","search","settings","stack","subscribe","trace","unlock","unsubscribe","use"]},"res":{"description":"After middleware.init executed, Request will contain res and next properties\nSee: express/lib/middleware/init.js","type":"object","properties":{"send":{"description":"Send a response.\n\nExamples:\n\n    res.send(new Buffer('wahoo'));\n    res.send({ some: 'json' });\n    res.send('<p>some html</p>');\n    res.status(404).send('Sorry, cant find that');","type":"object"},"json":{"description":"Send JSON response.\n\nExamples:\n\n    res.json(null);\n    res.json({ user: 'tj' });\n    res.status(500).json('oh noes!');\n    res.status(404).json('I dont have that');","type":"object"},"jsonp":{"description":"Send JSON response with JSONP callback support.\n\nExamples:\n\n    res.jsonp(null);\n    res.jsonp({ user: 'tj' });\n    res.status(500).jsonp('oh noes!');\n    res.status(404).jsonp('I dont have that');","type":"object"},"headersSent":{"description":"Read-only. `true` if the headers were sent, otherwise `false`.","type":"boolean"},"locals":{"type":"object"},"charset":{"type":"string"},"app":{"type":"object","properties":{"get":{"type":"object"},"router":{"type":"string"},"settings":{},"resource":{},"map":{},"locals":{"type":"object"},"routes":{"description":"The app.routes object houses all of the routes defined mapped by the\nassociated HTTP verb. This object may be used for introspection\ncapabilities, for example Express uses this internally not only for\nrouting but to provide default OPTIONS behaviour unless app.options()\nis used. Your application or framework may also remove routes by\nsimply by removing them from this object."},"_router":{"description":"Used to get all registered routes in Express Application"},"use":{"type":"object"},"on":{"description":"The mount event is fired on a sub-app, when it is mounted on a parent app.\nThe parent app is passed to the callback function.\n\nNOTE:\nSub-apps will:\n - Not inherit the value of settings that have a default value. You must set the value in the sub-app.\n - Inherit the value of settings with no default value.","type":"object"},"mountpath":{"description":"The app.mountpath property contains one or more path patterns on which a sub-app was mounted.","anyOf":[{"type":"array","items":{"type":"string"}},{"type":"string"}]},"all":{"description":"Special-cased \"all\" method, applying the given route `path`,\nmiddleware, and callback to _every_ HTTP method.","type":"object"},"post":{"type":"object"},"put":{"type":"object"},"delete":{"type":"object"},"patch":{"type":"object"},"options":{"type":"object"},"head":{"type":"object"},"checkout":{"type":"object"},"connect":{"type":"object"},"copy":{"type":"object"},"lock":{"type":"object"},"merge":{"type":"object"},"mkactivity":{"type":"object"},"mkcol":{"type":"object"},"move":{"type":"object"},"m-search":{"type":"object"},"notify":{"type":"object"},"propfind":{"type":"object"},"proppatch":{"type":"object"},"purge":{"type":"object"},"report":{"type":"object"},"search":{"type":"object"},"subscribe":{"type":"object"},"trace":{"type":"object"},"unlock":{"type":"object"},"unsubscribe":{"type":"object"},"stack":{"description":"Stack of configured routes","type":"array","items":{}}},"required":["_router","all","checkout","connect","copy","delete","get","head","locals","lock","m-search","map","merge","mkactivity","mkcol","mountpath","move","notify","on","options","patch","post","propfind","proppatch","purge","put","report","resource","router","routes","search","settings","stack","subscribe","trace","unlock","unsubscribe","use"]},"req":{"$ref":"#/definitions/Request<ParamsDictionary,any,any,qs.ParsedQs,Record<string,any>>","description":"After middleware.init executed, Response will contain req property\nSee: express/lib/middleware/init.js"},"statusCode":{"description":"When using implicit headers (not calling `response.writeHead()` explicitly),\nthis property controls the status code that will be sent to the client when\nthe headers get flushed.\n\n```js\nresponse.statusCode = 404;\n```\n\nAfter response header was sent to the client, this property indicates the\nstatus code which was sent out.","type":"number"},"statusMessage":{"description":"When using implicit headers (not calling `response.writeHead()` explicitly),\nthis property controls the status message that will be sent to the client when\nthe headers get flushed. If this is left as `undefined` then the standard\nmessage for the status code will be used.\n\n```js\nresponse.statusMessage = 'Not found';\n```\n\nAfter response header was sent to the client, this property indicates the\nstatus message which was sent out.","type":"string"},"chunkedEncoding":{"type":"boolean"},"shouldKeepAlive":{"type":"boolean"},"useChunkedEncodingByDefault":{"type":"boolean"},"sendDate":{"type":"boolean"},"finished":{"type":"boolean"},"connection":{"description":"Aliases of `outgoingMessage.socket`","anyOf":[{"description":"This class is an abstraction of a TCP socket or a streaming `IPC` endpoint\n(uses named pipes on Windows, and Unix domain sockets otherwise). It is also\nan `EventEmitter`.\n\nA `net.Socket` can be created by the user and used directly to interact with\na server. For example, it is returned by {@link createConnection},\nso the user can use it to talk to the server.\n\nIt can also be created by Node.js and passed to the user when a connection\nis received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use\nit to interact with the client.","type":"object","properties":{"bufferSize":{"description":"This property shows the number of characters buffered for writing. The buffer\nmay contain strings whose length after encoding is not yet known. So this number\nis only an approximation of the number of bytes in the buffer.\n\n`net.Socket` has the property that `socket.write()` always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket. The network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible.\n\nThe consequence of this internal buffering is that memory may grow.\nUsers who experience large or growing `bufferSize` should attempt to\n\"throttle\" the data flows in their program with `socket.pause()` and `socket.resume()`.","type":"number"},"bytesRead":{"description":"The amount of received bytes.","type":"number"},"bytesWritten":{"description":"The amount of bytes sent.","type":"number"},"connecting":{"description":"If `true`,`socket.connect(options[, connectListener])` was\ncalled and has not yet finished. It will stay `true` until the socket becomes\nconnected, then it is set to `false` and the `'connect'` event is emitted. Note\nthat the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.","type":"boolean"},"destroyed":{"description":"See `writable.destroyed` for further details.","type":"boolean"},"localAddress":{"description":"The string representation of the local IP address the remote client is\nconnecting on. For example, in a server listening on `'0.0.0.0'`, if a client\nconnects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.","type":"string"},"localPort":{"description":"The numeric representation of the local port. For example, `80` or `21`.","type":"number"},"localFamily":{"description":"The string representation of the local IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"readyState":{"description":"This property represents the state of the connection as a string.","enum":["closed","open","opening","readOnly","writeOnly"],"type":"string"},"remoteAddress":{"description":"The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).","type":"string"},"remoteFamily":{"description":"The string representation of the remote IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"remotePort":{"description":"The numeric representation of the remote port. For example, `80` or `21`.","type":"number"},"timeout":{"description":"The socket timeout in milliseconds as set by socket.setTimeout(). It is undefined if a timeout has not been set.","type":"number"},"writable":{"description":"Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.","type":"boolean"},"writableEnded":{"description":"Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.","type":"boolean"},"writableFinished":{"description":"Is set to `true` immediately before the `'finish'` event is emitted.","type":"boolean"},"writableHighWaterMark":{"description":"Return the value of `highWaterMark` passed when creating this `Writable`.","type":"number"},"writableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"writableObjectMode":{"description":"Getter for the property `objectMode` of a given `Writable` stream.","type":"boolean"},"writableCorked":{"description":"Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.","type":"number"},"writableNeedDrain":{"description":"Is `true` if the stream's buffer has been full and stream will emit 'drain'.","type":"boolean"},"closed":{"description":"Is true after 'close' has been emitted.","type":"boolean"},"errored":{"description":"Returns error if the stream has been destroyed with an error.","anyOf":[{"type":"object","properties":{"name":{"type":"string"},"message":{"type":"string"},"stack":{"type":"string"}},"required":["message","name"]},{"type":"null"}]},"allowHalfOpen":{"description":"If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.","type":"boolean"},"readableAborted":{"description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","type":"boolean"},"readable":{"description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","type":"boolean"},"readableDidRead":{"description":"Returns whether `'data'` has been emitted.","type":"boolean"},"readableEncoding":{"description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","anyOf":[{"enum":["ascii","base64","base64url","binary","hex","latin1","ucs-2","ucs2","utf-8","utf16le","utf8"],"type":"string"},{"type":"null"}]},"readableEnded":{"description":"Becomes `true` when `'end'` event is emitted.","type":"boolean"},"readableFlowing":{"description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","type":["null","boolean"]},"readableHighWaterMark":{"description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","type":"number"},"readableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"readableObjectMode":{"description":"Getter for the property `objectMode` of a given `Readable` stream.","type":"boolean"}},"required":["allowHalfOpen","bufferSize","bytesRead","bytesWritten","closed","connecting","destroyed","errored","readable","readableAborted","readableDidRead","readableEncoding","readableEnded","readableFlowing","readableHighWaterMark","readableLength","readableObjectMode","readyState","writable","writableCorked","writableEnded","writableFinished","writableHighWaterMark","writableLength","writableNeedDrain","writableObjectMode"]},{"type":"null"}]},"socket":{"description":"Reference to the underlying socket. Usually, users will not want to access\nthis property.\n\nAfter calling `outgoingMessage.end()`, this property will be nulled.","anyOf":[{"description":"This class is an abstraction of a TCP socket or a streaming `IPC` endpoint\n(uses named pipes on Windows, and Unix domain sockets otherwise). It is also\nan `EventEmitter`.\n\nA `net.Socket` can be created by the user and used directly to interact with\na server. For example, it is returned by {@link createConnection},\nso the user can use it to talk to the server.\n\nIt can also be created by Node.js and passed to the user when a connection\nis received. For example, it is passed to the listeners of a `'connection'` event emitted on a {@link Server}, so the user can use\nit to interact with the client.","type":"object","properties":{"bufferSize":{"description":"This property shows the number of characters buffered for writing. The buffer\nmay contain strings whose length after encoding is not yet known. So this number\nis only an approximation of the number of bytes in the buffer.\n\n`net.Socket` has the property that `socket.write()` always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket. The network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible.\n\nThe consequence of this internal buffering is that memory may grow.\nUsers who experience large or growing `bufferSize` should attempt to\n\"throttle\" the data flows in their program with `socket.pause()` and `socket.resume()`.","type":"number"},"bytesRead":{"description":"The amount of received bytes.","type":"number"},"bytesWritten":{"description":"The amount of bytes sent.","type":"number"},"connecting":{"description":"If `true`,`socket.connect(options[, connectListener])` was\ncalled and has not yet finished. It will stay `true` until the socket becomes\nconnected, then it is set to `false` and the `'connect'` event is emitted. Note\nthat the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.","type":"boolean"},"destroyed":{"description":"See `writable.destroyed` for further details.","type":"boolean"},"localAddress":{"description":"The string representation of the local IP address the remote client is\nconnecting on. For example, in a server listening on `'0.0.0.0'`, if a client\nconnects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.","type":"string"},"localPort":{"description":"The numeric representation of the local port. For example, `80` or `21`.","type":"number"},"localFamily":{"description":"The string representation of the local IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"readyState":{"description":"This property represents the state of the connection as a string.","enum":["closed","open","opening","readOnly","writeOnly"],"type":"string"},"remoteAddress":{"description":"The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).","type":"string"},"remoteFamily":{"description":"The string representation of the remote IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"remotePort":{"description":"The numeric representation of the remote port. For example, `80` or `21`.","type":"number"},"timeout":{"description":"The socket timeout in milliseconds as set by socket.setTimeout(). It is undefined if a timeout has not been set.","type":"number"},"writable":{"description":"Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.","type":"boolean"},"writableEnded":{"description":"Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.","type":"boolean"},"writableFinished":{"description":"Is set to `true` immediately before the `'finish'` event is emitted.","type":"boolean"},"writableHighWaterMark":{"description":"Return the value of `highWaterMark` passed when creating this `Writable`.","type":"number"},"writableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"writableObjectMode":{"description":"Getter for the property `objectMode` of a given `Writable` stream.","type":"boolean"},"writableCorked":{"description":"Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.","type":"number"},"writableNeedDrain":{"description":"Is `true` if the stream's buffer has been full and stream will emit 'drain'.","type":"boolean"},"closed":{"description":"Is true after 'close' has been emitted.","type":"boolean"},"errored":{"description":"Returns error if the stream has been destroyed with an error.","anyOf":[{"type":"object","properties":{"name":{"type":"string"},"message":{"type":"string"},"stack":{"type":"string"}},"required":["message","name"]},{"type":"null"}]},"allowHalfOpen":{"description":"If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.","type":"boolean"},"readableAborted":{"description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","type":"boolean"},"readable":{"description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","type":"boolean"},"readableDidRead":{"description":"Returns whether `'data'` has been emitted.","type":"boolean"},"readableEncoding":{"description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","anyOf":[{"enum":["ascii","base64","base64url","binary","hex","latin1","ucs-2","ucs2","utf-8","utf16le","utf8"],"type":"string"},{"type":"null"}]},"readableEnded":{"description":"Becomes `true` when `'end'` event is emitted.","type":"boolean"},"readableFlowing":{"description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","type":["null","boolean"]},"readableHighWaterMark":{"description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","type":"number"},"readableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"readableObjectMode":{"description":"Getter for the property `objectMode` of a given `Readable` stream.","type":"boolean"}},"required":["allowHalfOpen","bufferSize","bytesRead","bytesWritten","closed","connecting","destroyed","errored","readable","readableAborted","readableDidRead","readableEncoding","readableEnded","readableFlowing","readableHighWaterMark","readableLength","readableObjectMode","readyState","writable","writableCorked","writableEnded","writableFinished","writableHighWaterMark","writableLength","writableNeedDrain","writableObjectMode"]},{"type":"null"}]},"writable":{"description":"Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.","type":"boolean"},"writableEnded":{"description":"Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.","type":"boolean"},"writableFinished":{"description":"Is set to `true` immediately before the `'finish'` event is emitted.","type":"boolean"},"writableHighWaterMark":{"description":"Return the value of `highWaterMark` passed when creating this `Writable`.","type":"number"},"writableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"writableObjectMode":{"description":"Getter for the property `objectMode` of a given `Writable` stream.","type":"boolean"},"writableCorked":{"description":"Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.","type":"number"},"destroyed":{"description":"Is `true` after `writable.destroy()` has been called.","type":"boolean"},"closed":{"description":"Is true after 'close' has been emitted.","type":"boolean"},"errored":{"description":"Returns error if the stream has been destroyed with an error.","anyOf":[{"type":"object","properties":{"name":{"type":"string"},"message":{"type":"string"},"stack":{"type":"string"}},"required":["message","name"]},{"type":"null"}]},"writableNeedDrain":{"description":"Is `true` if the stream's buffer has been full and stream will emit 'drain'.","type":"boolean"}},"required":["app","charset","chunkedEncoding","closed","connection","destroyed","errored","finished","headersSent","json","jsonp","locals","req","send","sendDate","shouldKeepAlive","socket","statusCode","statusMessage","useChunkedEncodingByDefault","writable","writableCorked","writableEnded","writableFinished","writableHighWaterMark","writableLength","writableNeedDrain","writableObjectMode"]},"next":{"type":"object"},"aborted":{"description":"The `message.aborted` property will be `true` if the request has\nbeen aborted.","type":"boolean"},"httpVersion":{"description":"In case of server request, the HTTP version sent by the client. In the case of\nclient response, the HTTP version of the connected-to server.\nProbably either `'1.1'` or `'1.0'`.\n\nAlso `message.httpVersionMajor` is the first integer and`message.httpVersionMinor` is the second.","type":"string"},"httpVersionMajor":{"type":"number"},"httpVersionMinor":{"type":"number"},"complete":{"description":"The `message.complete` property will be `true` if a complete HTTP message has\nbeen received and successfully parsed.\n\nThis property is particularly useful as a means of determining if a client or\nserver fully transmitted a message before a connection was terminated:\n\n```js\nconst req = http.request({\n  host: '127.0.0.1',\n  port: 8080,\n  method: 'POST'\n}, (res) => {\n  res.resume();\n  res.on('end', () => {\n    if (!res.complete)\n      console.error(\n        'The connection was terminated while the message was still being sent');\n  });\n});\n```","type":"boolean"},"connection":{"description":"Alias for `message.socket`.","type":"object","properties":{"bufferSize":{"description":"This property shows the number of characters buffered for writing. The buffer\nmay contain strings whose length after encoding is not yet known. So this number\nis only an approximation of the number of bytes in the buffer.\n\n`net.Socket` has the property that `socket.write()` always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket. The network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible.\n\nThe consequence of this internal buffering is that memory may grow.\nUsers who experience large or growing `bufferSize` should attempt to\n\"throttle\" the data flows in their program with `socket.pause()` and `socket.resume()`.","type":"number"},"bytesRead":{"description":"The amount of received bytes.","type":"number"},"bytesWritten":{"description":"The amount of bytes sent.","type":"number"},"connecting":{"description":"If `true`,`socket.connect(options[, connectListener])` was\ncalled and has not yet finished. It will stay `true` until the socket becomes\nconnected, then it is set to `false` and the `'connect'` event is emitted. Note\nthat the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.","type":"boolean"},"destroyed":{"description":"See `writable.destroyed` for further details.","type":"boolean"},"localAddress":{"description":"The string representation of the local IP address the remote client is\nconnecting on. For example, in a server listening on `'0.0.0.0'`, if a client\nconnects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.","type":"string"},"localPort":{"description":"The numeric representation of the local port. For example, `80` or `21`.","type":"number"},"localFamily":{"description":"The string representation of the local IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"readyState":{"description":"This property represents the state of the connection as a string.","enum":["closed","open","opening","readOnly","writeOnly"],"type":"string"},"remoteAddress":{"description":"The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).","type":"string"},"remoteFamily":{"description":"The string representation of the remote IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"remotePort":{"description":"The numeric representation of the remote port. For example, `80` or `21`.","type":"number"},"timeout":{"description":"The socket timeout in milliseconds as set by socket.setTimeout(). It is undefined if a timeout has not been set.","type":"number"},"writable":{"description":"Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.","type":"boolean"},"writableEnded":{"description":"Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.","type":"boolean"},"writableFinished":{"description":"Is set to `true` immediately before the `'finish'` event is emitted.","type":"boolean"},"writableHighWaterMark":{"description":"Return the value of `highWaterMark` passed when creating this `Writable`.","type":"number"},"writableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"writableObjectMode":{"description":"Getter for the property `objectMode` of a given `Writable` stream.","type":"boolean"},"writableCorked":{"description":"Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.","type":"number"},"writableNeedDrain":{"description":"Is `true` if the stream's buffer has been full and stream will emit 'drain'.","type":"boolean"},"closed":{"description":"Is true after 'close' has been emitted.","type":"boolean"},"errored":{"description":"Returns error if the stream has been destroyed with an error.","anyOf":[{"type":"object","properties":{"name":{"type":"string"},"message":{"type":"string"},"stack":{"type":"string"}},"required":["message","name"]},{"type":"null"}]},"allowHalfOpen":{"description":"If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.","type":"boolean"},"readableAborted":{"description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","type":"boolean"},"readable":{"description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","type":"boolean"},"readableDidRead":{"description":"Returns whether `'data'` has been emitted.","type":"boolean"},"readableEncoding":{"description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","anyOf":[{"enum":["ascii","base64","base64url","binary","hex","latin1","ucs-2","ucs2","utf-8","utf16le","utf8"],"type":"string"},{"type":"null"}]},"readableEnded":{"description":"Becomes `true` when `'end'` event is emitted.","type":"boolean"},"readableFlowing":{"description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","type":["null","boolean"]},"readableHighWaterMark":{"description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","type":"number"},"readableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"readableObjectMode":{"description":"Getter for the property `objectMode` of a given `Readable` stream.","type":"boolean"}},"required":["allowHalfOpen","bufferSize","bytesRead","bytesWritten","closed","connecting","destroyed","errored","readable","readableAborted","readableDidRead","readableEncoding","readableEnded","readableFlowing","readableHighWaterMark","readableLength","readableObjectMode","readyState","writable","writableCorked","writableEnded","writableFinished","writableHighWaterMark","writableLength","writableNeedDrain","writableObjectMode"]},"socket":{"description":"The `net.Socket` object associated with the connection.\n\nWith HTTPS support, use `request.socket.getPeerCertificate()` to obtain the\nclient's authentication details.\n\nThis property is guaranteed to be an instance of the `net.Socket` class,\na subclass of `stream.Duplex`, unless the user specified a socket\ntype other than `net.Socket` or internally nulled.","type":"object","properties":{"bufferSize":{"description":"This property shows the number of characters buffered for writing. The buffer\nmay contain strings whose length after encoding is not yet known. So this number\nis only an approximation of the number of bytes in the buffer.\n\n`net.Socket` has the property that `socket.write()` always works. This is to\nhelp users get up and running quickly. The computer cannot always keep up\nwith the amount of data that is written to a socket. The network connection\nsimply might be too slow. Node.js will internally queue up the data written to a\nsocket and send it out over the wire when it is possible.\n\nThe consequence of this internal buffering is that memory may grow.\nUsers who experience large or growing `bufferSize` should attempt to\n\"throttle\" the data flows in their program with `socket.pause()` and `socket.resume()`.","type":"number"},"bytesRead":{"description":"The amount of received bytes.","type":"number"},"bytesWritten":{"description":"The amount of bytes sent.","type":"number"},"connecting":{"description":"If `true`,`socket.connect(options[, connectListener])` was\ncalled and has not yet finished. It will stay `true` until the socket becomes\nconnected, then it is set to `false` and the `'connect'` event is emitted. Note\nthat the `socket.connect(options[, connectListener])` callback is a listener for the `'connect'` event.","type":"boolean"},"destroyed":{"description":"See `writable.destroyed` for further details.","type":"boolean"},"localAddress":{"description":"The string representation of the local IP address the remote client is\nconnecting on. For example, in a server listening on `'0.0.0.0'`, if a client\nconnects on `'192.168.1.1'`, the value of `socket.localAddress` would be`'192.168.1.1'`.","type":"string"},"localPort":{"description":"The numeric representation of the local port. For example, `80` or `21`.","type":"number"},"localFamily":{"description":"The string representation of the local IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"readyState":{"description":"This property represents the state of the connection as a string.","enum":["closed","open","opening","readOnly","writeOnly"],"type":"string"},"remoteAddress":{"description":"The string representation of the remote IP address. For example,`'74.125.127.100'` or `'2001:4860:a005::68'`. Value may be `undefined` if\nthe socket is destroyed (for example, if the client disconnected).","type":"string"},"remoteFamily":{"description":"The string representation of the remote IP family. `'IPv4'` or `'IPv6'`.","type":"string"},"remotePort":{"description":"The numeric representation of the remote port. For example, `80` or `21`.","type":"number"},"timeout":{"description":"The socket timeout in milliseconds as set by socket.setTimeout(). It is undefined if a timeout has not been set.","type":"number"},"writable":{"description":"Is `true` if it is safe to call `writable.write()`, which means\nthe stream has not been destroyed, errored or ended.","type":"boolean"},"writableEnded":{"description":"Is `true` after `writable.end()` has been called. This property\ndoes not indicate whether the data has been flushed, for this use `writable.writableFinished` instead.","type":"boolean"},"writableFinished":{"description":"Is set to `true` immediately before the `'finish'` event is emitted.","type":"boolean"},"writableHighWaterMark":{"description":"Return the value of `highWaterMark` passed when creating this `Writable`.","type":"number"},"writableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be written. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"writableObjectMode":{"description":"Getter for the property `objectMode` of a given `Writable` stream.","type":"boolean"},"writableCorked":{"description":"Number of times `writable.uncork()` needs to be\ncalled in order to fully uncork the stream.","type":"number"},"writableNeedDrain":{"description":"Is `true` if the stream's buffer has been full and stream will emit 'drain'.","type":"boolean"},"closed":{"description":"Is true after 'close' has been emitted.","type":"boolean"},"errored":{"description":"Returns error if the stream has been destroyed with an error.","anyOf":[{"type":"object","properties":{"name":{"type":"string"},"message":{"type":"string"},"stack":{"type":"string"}},"required":["message","name"]},{"type":"null"}]},"allowHalfOpen":{"description":"If `false` then the stream will automatically end the writable side when the\nreadable side ends. Set initially by the `allowHalfOpen` constructor option,\nwhich defaults to `false`.\n\nThis can be changed manually to change the half-open behavior of an existing`Duplex` stream instance, but must be changed before the `'end'` event is\nemitted.","type":"boolean"},"readableAborted":{"description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","type":"boolean"},"readable":{"description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","type":"boolean"},"readableDidRead":{"description":"Returns whether `'data'` has been emitted.","type":"boolean"},"readableEncoding":{"description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","anyOf":[{"enum":["ascii","base64","base64url","binary","hex","latin1","ucs-2","ucs2","utf-8","utf16le","utf8"],"type":"string"},{"type":"null"}]},"readableEnded":{"description":"Becomes `true` when `'end'` event is emitted.","type":"boolean"},"readableFlowing":{"description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","type":["null","boolean"]},"readableHighWaterMark":{"description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","type":"number"},"readableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"readableObjectMode":{"description":"Getter for the property `objectMode` of a given `Readable` stream.","type":"boolean"}},"required":["allowHalfOpen","bufferSize","bytesRead","bytesWritten","closed","connecting","destroyed","errored","readable","readableAborted","readableDidRead","readableEncoding","readableEnded","readableFlowing","readableHighWaterMark","readableLength","readableObjectMode","readyState","writable","writableCorked","writableEnded","writableFinished","writableHighWaterMark","writableLength","writableNeedDrain","writableObjectMode"]},"headers":{"description":"The request/response headers object.\n\nKey-value pairs of header names and values. Header names are lower-cased.\n\n```js\n// Prints something like:\n//\n// { 'user-agent': 'curl/7.22.0',\n//   host: '127.0.0.1:8000',\n//   accept: '*' }\nconsole.log(request.getHeaders());\n```\n\nDuplicates in raw headers are handled in the following ways, depending on the\nheader name:\n\n* Duplicates of `age`, `authorization`, `content-length`, `content-type`,`etag`, `expires`, `from`, `host`, `if-modified-since`, `if-unmodified-since`,`last-modified`, `location`,\n`max-forwards`, `proxy-authorization`, `referer`,`retry-after`, `server`, or `user-agent` are discarded.\n* `set-cookie` is always an array. Duplicates are added to the array.\n* For duplicate `cookie` headers, the values are joined together with '; '.\n* For all other headers, the values are joined together with ', '.","type":"object","properties":{"accept":{"type":"string"},"accept-language":{"type":"string"},"accept-patch":{"type":"string"},"accept-ranges":{"type":"string"},"access-control-allow-credentials":{"type":"string"},"access-control-allow-headers":{"type":"string"},"access-control-allow-methods":{"type":"string"},"access-control-allow-origin":{"type":"string"},"access-control-expose-headers":{"type":"string"},"access-control-max-age":{"type":"string"},"access-control-request-headers":{"type":"string"},"access-control-request-method":{"type":"string"},"age":{"type":"string"},"allow":{"type":"string"},"alt-svc":{"type":"string"},"authorization":{"type":"string"},"cache-control":{"type":"string"},"connection":{"type":"string"},"content-disposition":{"type":"string"},"content-encoding":{"type":"string"},"content-language":{"type":"string"},"content-length":{"type":"string"},"content-location":{"type":"string"},"content-range":{"type":"string"},"content-type":{"type":"string"},"cookie":{"type":"string"},"date":{"type":"string"},"etag":{"type":"string"},"expect":{"type":"string"},"expires":{"type":"string"},"forwarded":{"type":"string"},"from":{"type":"string"},"host":{"type":"string"},"if-match":{"type":"string"},"if-modified-since":{"type":"string"},"if-none-match":{"type":"string"},"if-unmodified-since":{"type":"string"},"last-modified":{"type":"string"},"location":{"type":"string"},"origin":{"type":"string"},"pragma":{"type":"string"},"proxy-authenticate":{"type":"string"},"proxy-authorization":{"type":"string"},"public-key-pins":{"type":"string"},"range":{"type":"string"},"referer":{"type":"string"},"retry-after":{"type":"string"},"sec-websocket-accept":{"type":"string"},"sec-websocket-extensions":{"type":"string"},"sec-websocket-key":{"type":"string"},"sec-websocket-protocol":{"type":"string"},"sec-websocket-version":{"type":"string"},"set-cookie":{"type":"array","items":{"type":"string"}},"strict-transport-security":{"type":"string"},"tk":{"type":"string"},"trailer":{"type":"string"},"transfer-encoding":{"type":"string"},"upgrade":{"type":"string"},"user-agent":{"type":"string"},"vary":{"type":"string"},"via":{"type":"string"},"warning":{"type":"string"},"www-authenticate":{"type":"string"}}},"rawHeaders":{"description":"The raw request/response headers list exactly as they were received.\n\nThe keys and values are in the same list. It is _not_ a\nlist of tuples. So, the even-numbered offsets are key values, and the\nodd-numbered offsets are the associated values.\n\nHeader names are not lowercased, and duplicates are not merged.\n\n```js\n// Prints something like:\n//\n// [ 'user-agent',\n//   'this is invalid because there can be only one',\n//   'User-Agent',\n//   'curl/7.22.0',\n//   'Host',\n//   '127.0.0.1:8000',\n//   'ACCEPT',\n//   '*' ]\nconsole.log(request.rawHeaders);\n```","type":"array","items":{"type":"string"}},"trailers":{"description":"The request/response trailers object. Only populated at the `'end'` event.","type":"object","additionalProperties":{"type":"object"}},"rawTrailers":{"description":"The raw request/response trailer keys and values exactly as they were\nreceived. Only populated at the `'end'` event.","type":"array","items":{"type":"string"}},"statusCode":{"description":"**Only valid for response obtained from {@link ClientRequest}.**\n\nThe 3-digit HTTP response status code. E.G. `404`.","type":"number"},"statusMessage":{"description":"**Only valid for response obtained from {@link ClientRequest}.**\n\nThe HTTP response status message (reason phrase). E.G. `OK` or `Internal Server Error`.","type":"string"},"readableAborted":{"description":"Returns whether the stream was destroyed or errored before emitting `'end'`.","type":"boolean"},"readable":{"description":"Is `true` if it is safe to call `readable.read()`, which means\nthe stream has not been destroyed or emitted `'error'` or `'end'`.","type":"boolean"},"readableDidRead":{"description":"Returns whether `'data'` has been emitted.","type":"boolean"},"readableEncoding":{"description":"Getter for the property `encoding` of a given `Readable` stream. The `encoding`property can be set using the `readable.setEncoding()` method.","anyOf":[{"enum":["ascii","base64","base64url","binary","hex","latin1","ucs-2","ucs2","utf-8","utf16le","utf8"],"type":"string"},{"type":"null"}]},"readableEnded":{"description":"Becomes `true` when `'end'` event is emitted.","type":"boolean"},"readableFlowing":{"description":"This property reflects the current state of a `Readable` stream as described\nin the `Three states` section.","type":["null","boolean"]},"readableHighWaterMark":{"description":"Returns the value of `highWaterMark` passed when creating this `Readable`.","type":"number"},"readableLength":{"description":"This property contains the number of bytes (or objects) in the queue\nready to be read. The value provides introspection data regarding\nthe status of the `highWaterMark`.","type":"number"},"readableObjectMode":{"description":"Getter for the property `objectMode` of a given `Readable` stream.","type":"boolean"},"destroyed":{"description":"Is `true` after `readable.destroy()` has been called.","type":"boolean"},"closed":{"description":"Is true after 'close' has been emitted.","type":"boolean"},"errored":{"description":"Returns error if the stream has been destroyed with an error.","anyOf":[{"type":"object","properties":{"name":{"type":"string"},"message":{"type":"string"},"stack":{"type":"string"}},"required":["message","name"]},{"type":"null"}]}},"required":["aborted","accepted","app","baseUrl","body","closed","complete","connection","cookies","destroyed","errored","fresh","headers","host","hostname","httpVersion","httpVersionMajor","httpVersionMinor","ip","ips","method","originalUrl","params","path","protocol","query","rawHeaders","rawTrailers","readable","readableAborted","readableDidRead","readableEncoding","readableEnded","readableFlowing","readableHighWaterMark","readableLength","readableObjectMode","route","secure","signedCookies","socket","stale","subdomains","trailers","url","xhr"]},"FlightType":{"enum":["businessClass","economyClass","firstClass"],"type":"string"},"GetTransactionIdResponse":{"type":"object","properties":{"transactionId":{"type":"number"}},"required":["transactionId"]},"Ticket":{"allOf":[{"type":"object","properties":{"economyClass":{"type":"object","properties":{"price":{"type":"number"},"seats":{"type":"number"}},"required":["price","seats"]},"businessClass":{"type":"object","properties":{"price":{"type":"number"},"seats":{"type":"number"}},"required":["price","seats"]},"firstClass":{"type":"object","properties":{"price":{"type":"number"},"seats":{"type":"number"}},"required":["price","seats"]}},"required":["businessClass","economyClass","firstClass"]},{"type":"object","properties":{"id":{"type":"string"},"origin":{"type":"string"},"destination":{"type":"string"},"departure_date":{"type":"string"},"arrival_date":{"type":"string"},"duration":{"type":"number"}},"required":["arrival_date","departure_date","destination","duration","id","origin"]}]},"UserTicket":{"type":"object","properties":{"flightType":{"enum":["businessClass","economyClass","firstClass"],"type":"string"},"id":{"type":"string"},"origin":{"type":"string"},"destination":{"type":"string"},"departure_date":{"type":"string"},"arrival_date":{"type":"string"},"duration":{"type":"number"}},"required":["arrival_date","departure_date","destination","duration","flightType","id","origin"]},"GetTicketsRequest":{"type":"object","properties":{"origin":{"type":"string"},"destination":{"type":"string"},"departure_date":{"type":"string"},"passengersCount":{"type":"number"}},"required":["departure_date","destination","origin","passengersCount"]},"GetTransactionRequest":{"type":"object","properties":{"amount":{"type":"number"},"callback":{"type":"string"}},"required":["amount","callback"]},"SubmitPurchaseRequest":{"type":"object","properties":{"amount":{"type":"number"},"flightId":{"type":"string"},"flightType":{"enum":["businessClass","economyClass","firstClass"],"type":"string"},"transactionId":{"type":"number"},"transactionResult":{"type":"number"}},"required":["amount","flightId","flightType","transactionId","transactionResult"]},"GetUserInfoResponse":{"type":"object","properties":{"id":{"type":"string"},"name":{"type":"string"},"lastname":{"type":"string"}},"required":["id","lastname","name"]}}} as const;
export default schema.definitions;